#!/usr/bin/env python3\n\"\"\"\nFFmpeg Quantum Animation Pipeline\nConverts C++ solver output + Manim animations â†’ MP4/GIF with professional encoding\nSupports: 4K, 60fps, multiple codecs, quality optimization\n\"\"\"\n\nimport subprocess\nimport os\nimport json\nfrom pathlib import Path\nfrom typing import Optional, List\nimport sys\n\n\nclass QuantumAnimationPipeline:\n    \"\"\"Professional animation rendering with FFmpeg\"\"\"\n    \n    def __init__(self, output_dir=\"outputs/animations\"):\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        self.ffmpeg_bin = self._find_ffmpeg()\n    \n    @staticmethod\n    def _find_ffmpeg() -> str:\n        \"\"\"Locate FFmpeg executable\"\"\"\n        try:\n            result = subprocess.run([\"which\", \"ffmpeg\"], capture_output=True, text=True)\n            if result.returncode == 0:\n                return result.stdout.strip()\n        except:\n            pass\n        \n        # Common paths\n        for path in [\"/usr/bin/ffmpeg\", \"/usr/local/bin/ffmpeg\", \"ffmpeg\"]:\n            if subprocess.run([\"which\", path], capture_output=True).returncode == 0:\n                return path\n        \n        raise RuntimeError(\"FFmpeg not found. Install with: apt install ffmpeg\")\n    \n    def mp4_encode_4k(\n        self,\n        input_file: str,\n        output_name: str,\n        bitrate: str = \"50M\",\n        preset: str = \"slow\",\n        fps: int = 60\n    ) -> Path:\n        \"\"\"\n        Encode to 4K MP4 with H.265 (HEVC) codec\n        \n        Args:\n            input_file: Input video/image sequence\n            output_name: Output filename (without extension)\n            bitrate: Target bitrate (e.g., '50M' for 50 Mbps)\n            preset: Encoding speed (ultrafast < fast < medium < slow < placebo)\n            fps: Frames per second (60 for smooth animations)\n        \n        Returns:\n            Path to output MP4 file\n        \"\"\"\n        output_path = self.output_dir / f\"{output_name}.mp4\"\n        \n        cmd = [\n            self.ffmpeg_bin,\n            \"-i\", str(input_file),\n            \"-c:v\", \"libx265\",        # H.265 codec (better compression)\n            \"-crf\", \"23\",              # Quality (0-51, lower=better, 23=default)\n            \"-preset\", preset,          # Encoding speed\n            \"-b:v\", bitrate,            # Target bitrate\n            \"-fps_mode\", \"cfr\",\n            \"-r\", str(fps),\n            \"-c:a\", \"aac\",              # Audio codec\n            \"-b:a\", \"128k\",             # Audio bitrate\n            \"-pix_fmt\", \"yuv420p\",     # Pixel format (compatibility)\n            \"-y\",                       # Overwrite output\n            str(output_path)\n        ]\n        \n        print(f\"\\nðŸŽ¬ Encoding 4K MP4: {output_name}\")\n        print(f\"   Input: {input_file}\")\n        print(f\"   Output: {output_path}\")\n        print(f\"   Bitrate: {bitrate}, FPS: {fps}, Preset: {preset}\")\n        \n        try:\n            result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n            print(f\"   âœ… Encoding complete!\")\n            return output_path\n        except subprocess.CalledProcessError as e:\n            print(f\"   âŒ Error: {e.stderr}\")\n            raise\n    \n    def create_gif(\n        self,\n        input_file: str,\n        output_name: str,\n        fps: int = 30,\n        scale: int = 1024,\n        optimize: bool = True\n    ) -> Path:\n        \"\"\"\n        Create optimized GIF from video/images\n        \n        Args:\n            input_file: Input video or image sequence\n            output_name: Output filename (without extension)\n            fps: Frames per second\n            scale: Scale width (preserves aspect ratio)\n            optimize: Use palette optimization for smaller file size\n        \n        Returns:\n            Path to output GIF file\n        \"\"\"\n        output_path = self.output_dir / f\"{output_name}.gif\"\n        \n        # Two-pass encoding: generate palette then create GIF\n        palette_file = self.output_dir / f\"{output_name}_palette.png\"\n        \n        # Generate palette\n        palette_cmd = [\n            self.ffmpeg_bin,\n            \"-i\", str(input_file),\n            \"-vf\", f\"fps={fps},scale={scale}:-1:flags=lanczos,palettegen\",\n            \"-y\",\n            str(palette_file)\n        ]\n        \n        # Create GIF\n        gif_cmd = [\n            self.ffmpeg_bin,\n            \"-i\", str(input_file),\n            \"-i\", str(palette_file),\n            \"-filter_complex\", f\"fps={fps},scale={scale}:-1:flags=lanczos[x];[x][1:v]paletteuse\",\n            \"-y\",\n            str(output_path)\n        ]\n        \n        print(f\"\\nðŸŽ¨ Creating optimized GIF: {output_name}\")\n        print(f\"   Scale: {scale}px, FPS: {fps}\")\n        \n        try:\n            print(f\"   [1/2] Generating palette...\")\n            subprocess.run(palette_cmd, capture_output=True, check=True)\n            \n            print(f\"   [2/2] Creating GIF...\")\n            subprocess.run(gif_cmd, capture_output=True, check=True)\n            \n            # Cleanup palette\n            palette_file.unlink(missing_ok=True)\n            \n            file_size = output_path.stat().st_size / (1024 * 1024)\n            print(f\"   âœ… GIF created! Size: {file_size:.1f} MB\")\n            return output_path\n        \n        except subprocess.CalledProcessError as e:\n            print(f\"   âŒ Error: {e.stderr}\")\n            raise\n    \n    def extract_frames(\n        self,\n        input_file: str,\n        output_pattern: str,\n        fps: int = 60,\n        scale: Optional[int] = None\n    ) -> List[Path]:\n        \"\"\"\n        Extract frames from video for further processing\n        \n        Args:\n            input_file: Input video file\n            output_pattern: Pattern for output frames (e.g., \"frame_%04d.png\")\n            fps: Extract frames at this rate\n            scale: Optional scaling\n        \n        Returns:\n            List of extracted frame paths\n        \"\"\"\n        output_dir = self.output_dir / \"frames\"\n        output_dir.mkdir(exist_ok=True)\n        frame_path = output_dir / output_pattern\n        \n        vf_filter = f\"fps={fps}\"\n        if scale:\n            vf_filter += f\",scale={scale}:-1\"\n        \n        cmd = [\n            self.ffmpeg_bin,\n            \"-i\", str(input_file),\n            \"-vf\", vf_filter,\n            \"-q:v\", \"2\",  # High quality\n            \"-y\",\n            str(frame_path)\n        ]\n        \n        print(f\"\\nðŸ–¼ï¸  Extracting frames: {output_pattern}\")\n        \n        try:\n            subprocess.run(cmd, capture_output=True, check=True)\n            frame_files = sorted(output_dir.glob(\"*.png\"))\n            print(f\"   âœ… Extracted {len(frame_files)} frames\")\n            return frame_files\n        \n        except subprocess.CalledProcessError as e:\n            print(f\"   âŒ Error: {e.stderr}\")\n            raise\n    \n    def concat_videos(\n        self,\n        input_files: List[str],\n        output_name: str,\n        transition: str = \"none\"\n    ) -> Path:\n        \"\"\"\n        Concatenate multiple video files\n        \n        Args:\n            input_files: List of input video paths\n            output_name: Output filename\n            transition: Transition type (\"none\", \"fade\", \"crossfade\")\n        \n        Returns:\n            Path to concatenated output\n        \"\"\"\n        # Create concat demuxer file\n        concat_file = self.output_dir / \"concat.txt\"\n        with open(concat_file, \"w\") as f:\n            for file in input_files:\n                f.write(f\"file '{Path(file).absolute()}'\\n\")\n        \n        output_path = self.output_dir / f\"{output_name}.mp4\"\n        \n        cmd = [\n            self.ffmpeg_bin,\n            \"-f\", \"concat\",\n            \"-safe\", \"0\",\n            \"-i\", str(concat_file),\n            \"-c\", \"copy\",  # No re-encoding for speed\n            \"-y\",\n            str(output_path)\n        ]\n        \n        print(f\"\\nâ›“ï¸  Concatenating {len(input_files)} videos...\")\n        \n        try:\n            subprocess.run(cmd, capture_output=True, check=True)\n            concat_file.unlink()\n            print(f\"   âœ… Videos concatenated: {output_path}\")\n            return output_path\n        \n        except subprocess.CalledProcessError as e:\n            print(f\"   âŒ Error: {e.stderr}\")\n            raise\n    \n    def add_audio(\n        self,\n        video_file: str,\n        audio_file: str,\n        output_name: str\n    ) -> Path:\n        \"\"\"\n        Add audio track to video\n        \n        Args:\n            video_file: Input video\n            audio_file: Input audio\n            output_name: Output filename\n        \n        Returns:\n            Path to video with audio\n        \"\"\"\n        output_path = self.output_dir / f\"{output_name}.mp4\"\n        \n        cmd = [\n            self.ffmpeg_bin,\n            \"-i\", str(video_file),\n            \"-i\", str(audio_file),\n            \"-c:v\", \"copy\",\n            \"-c:a\", \"aac\",\n            \"-map\", \"0:v:0\",\n            \"-map\", \"1:a:0\",\n            \"-shortest\",\n            \"-y\",\n            str(output_path)\n        ]\n        \n        print(f\"\\nðŸ”Š Adding audio to video...\")\n        \n        try:\n            subprocess.run(cmd, capture_output=True, check=True)\n            print(f\"   âœ… Audio added: {output_path}\")\n            return output_path\n        \n        except subprocess.CalledProcessError as e:\n            print(f\"   âŒ Error: {e.stderr}\")\n            raise\n    \n    def get_video_info(self, video_file: str) -> dict:\n        \"\"\"\n        Get video metadata (resolution, duration, bitrate, etc.)\n        \n        Args:\n            video_file: Video file path\n        \n        Returns:\n            Dictionary with video information\n        \"\"\"\n        cmd = [\n            self.ffmpeg_bin,\n            \"-i\", str(video_file),\n            \"-hide_banner\"\n        ]\n        \n        result = subprocess.run(cmd, capture_output=True, text=True)\n        output = result.stderr  # FFmpeg outputs to stderr\n        \n        info = {}\n        \n        # Extract resolution\n        import re\n        resolution_match = re.search(r\"(\\d+)x(\\d+)\", output)\n        if resolution_match:\n            info[\"width\"] = int(resolution_match.group(1))\n            info[\"height\"] = int(resolution_match.group(2))\n        \n        # Extract duration\n        duration_match = re.search(r\"Duration: ([\\d:]+)\", output)\n        if duration_match:\n            info[\"duration\"] = duration_match.group(1)\n        \n        # Extract bitrate\n        bitrate_match = re.search(r\"(\\d+) kb/s\", output)\n        if bitrate_match:\n            info[\"bitrate\"] = bitrate_match.group(1)\n        \n        return info\n\n\n# ============================================================================\n# QUANTUM ANIMATION PIPELINE DEMO\n# ============================================================================\n\ndef demo_quantum_pipeline():\n    \"\"\"\n    Demonstration of complete quantum animation pipeline\n    \"\"\"\n    pipeline = QuantumAnimationPipeline()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"ðŸŒŒ QUANTUM ANIMATION PIPELINE DEMO ðŸŒŒ\")\n    print(\"=\"*60)\n    \n    print(f\"\\nðŸ“ FFmpeg: {pipeline.ffmpeg_bin}\")\n    print(f\"ðŸ“ Output Directory: {pipeline.output_dir}\")\n    \n    # Check FFmpeg version\n    try:\n        result = subprocess.run(\n            [pipeline.ffmpeg_bin, \"-version\"],\n            capture_output=True,\n            text=True\n        )\n        version_line = result.stdout.split(\"\\n\")[0]\n        print(f\"ðŸ“Š {version_line}\")\n    except:\n        pass\n    \n    print(\"\\n\" + \"-\"*60)\n    print(\"PIPELINE CAPABILITIES:\")\n    print(\"-\"*60)\n    \n    capabilities = [\n        (\"4K MP4 Encoding\", \"3840Ã—2160 @ 60fps with H.265 codec\"),\n        (\"Optimized GIF Export\", \"Palette-optimized GIFs for web\"),\n        (\"Frame Extraction\", \"Extract high-quality frame sequences\"),\n        (\"Video Concatenation\", \"Combine multiple animations\"),\n        (\"Audio Integration\", \"Add narration or soundtrack\"),\n        (\"Quality Analysis\", \"Check video metadata and properties\")\n    ]\n    \n    for i, (feature, description) in enumerate(capabilities, 1):\n        print(f\"\\n   {i}. {feature}\")\n        print(f\"      â””â”€ {description}\")\n    \n    print(\"\\n\" + \"-\"*60)\n    print(\"USAGE EXAMPLE:\")\n    print(\"-\"*60)\n    \n    example_code = '''\n    # Create pipeline\n    pipeline = QuantumAnimationPipeline()\n    \n    # Encode Manim output to 4K MP4\n    mp4_file = pipeline.mp4_encode_4k(\n        input_file=\"partial_movie_file_1080p60.mp4\",\n        output_name=\"quantum_harmonic_oscillator\",\n        bitrate=\"50M\",\n        preset=\"slow\",\n        fps=60\n    )\n    \n    # Create web-friendly GIF\n    gif_file = pipeline.create_gif(\n        input_file=\"quantum_harmonic_oscillator.mp4\",\n        output_name=\"quantum_harmonic_oscillator_preview\",\n        fps=30,\n        scale=1024\n    )\n    \n    # Extract frames for further editing\n    frames = pipeline.extract_frames(\n        input_file=\"quantum_harmonic_oscillator.mp4\",\n        output_pattern=\"frame_%04d.png\",\n        fps=60\n    )\n    \n    # Get video info\n    info = pipeline.get_video_info(\"quantum_harmonic_oscillator.mp4\")\n    print(f\"Resolution: {info['width']}Ã—{info['height']}\")\n    print(f\"Duration: {info['duration']}\")\n    '''\n    \n    for line in example_code.strip().split('\\n'):\n        print(line)\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"âœ… Pipeline ready for quantum animation rendering!\")\n    print(\"=\"*60 + \"\\n\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1 and sys.argv[1] == \"--demo\":\n        demo_quantum_pipeline()\n    else:\n        demo_quantum_pipeline()\n"